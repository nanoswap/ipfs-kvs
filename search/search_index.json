{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IPFS Key Value Store","text":"<p>github.com/nanoswap/ipfs-kvs</p>"},{"location":"#wrappers-for-ipfs-rpc-endpoints","title":"Wrappers for IPFS RPC endpoints","text":"<pre><code>import ipfs\nclient = ipfs.Ipfs()  # defaults to http://127.0.0.1:5001/api/v0\nclient.mkdir(\"my_dir\")\nclient.add(\"my_dir/my_file\", b\"my_contents\")\n</code></pre>"},{"location":"#read-and-write-protobuf-contents","title":"Read and write protobuf contents","text":""},{"location":"#reading","title":"Reading:","text":"<pre><code>    from nanoswap.ipfskvs import Store, Index, Ipfs\n    from myprotobuf_pb2 import MyProtobuf\n\n    store = Store(\n        Index.from_filename(\"myfile.txt\"),\n        ipfs=Ipfs(host=\"127.0.0.1\", port=\"5001\"),\n        reader=MyProtobuf()\n    )\n\n    store.read()\n    print(store.reader)\n</code></pre>"},{"location":"#writing","title":"Writing:","text":"<pre><code>    from nanoswap.ipfskvs import Store, Index, Ipfs\n    from myprotobuf_pb2 import MyProtobuf\n\n    store = Store(\n        Index.from_filename(\"myfile.txt\"),\n        ipfs=Ipfs(host=\"127.0.0.1\", port=\"5001\"),\n        writer=MyProtobuf()\n    )\n    store.add()\n</code></pre>"},{"location":"#overhead-for-nested-directories","title":"Overhead for nested directories","text":""},{"location":"#write-with-multiple-indexes","title":"Write with multiple indexes","text":"<p>Create a tiered file structure based on IDs, ex:</p> <pre><code>    \u251c\u2500\u2500 fashion/\n        \u251c\u2500\u2500 designer_1.manufacturer_1\n        \u251c\u2500\u2500 designer_2.manufacturer_1\n            \u251c\u2500\u2500 deal_16.data\n        \u251c\u2500\u2500 designer_4.manufacturer_3\n            \u251c\u2500\u2500 deal_1.data\n            \u251c\u2500\u2500 deal_2.data\n</code></pre> <pre><code>    from nanoswap.ipfskvs import Store, Index, Ipfs\n    from deal_pb2 import Deal\n\n    index = Index(\n        prefix=\"fashion\",\n        index={\n            \"designer\": str(uuid.uuid4()),\n            \"manufacturer\": str(uuid.uuid4())\n        }, subindex=Index(\n            index={\n                \"deal\":  str(uuid.uuid4())\n            }\n        )\n    )\n\n    data = Deal(type=Type.BUZZ, content=\"fizz\")\n    store = Store(index=index, ipfs=Ipfs(), writer=data)\n    store.add()\n</code></pre>"},{"location":"#query-the-multiple-indexes","title":"Query the multiple indexes","text":"<p>Ex: get all deals with designer id \"123\"</p> <pre><code>    from nanoswap.ipfskvs import Store, Index, Ipfs\n    from deal_pb2 import Deal\n\n    query_index = Index(\n        prefix=\"fashion\",\n        index={\n            \"designer\": \"123\"\n        }\n    )\n\n    reader = Deal()\n    query_results = Store.query(query_index, ipfs, reader)\n    print(Store.to_dataframe(query_results))\n</code></pre>"},{"location":"LICENSE/","title":"License","text":"<p>This is free and unencumbered software released into the public domain.</p> <p>Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.</p> <p>In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>For more information, please refer to https://unlicense.org</p>"},{"location":"classes_index/","title":"Index","text":""},{"location":"classes_index/#src.index.Index","title":"<code>src.index.Index</code>","text":"<p>An object for storing a nested directory structure.</p> <p>Use the <code>Store</code> class to read or write the data for an Index.</p>"},{"location":"classes_index/#src.index.Index--convert-a-filename-to-an-index-object","title":"Convert a filename to an Index object","text":"<pre><code>    index = Index.from_filename(\"mydir/show_1/season_2/episode_6.mp4\")\n</code></pre>"},{"location":"classes_index/#src.index.Index--convert-an-index-object-to-a-filename","title":"Convert an Index object to a filename","text":"<pre><code>    filename = index.get_filename()\n</code></pre> Source code in <code>src/index.py</code> <pre><code>class Index():\n\"\"\"An object for storing a nested directory structure.\n\n    Use the `Store` class to read or write the data for an Index.\n\n    ### Convert a filename to an Index object\n    ```py\n        index = Index.from_filename(\"mydir/show_1/season_2/episode_6.mp4\")\n    ```\n\n    ### Convert an Index object to a filename\n    ```py\n        filename = index.get_filename()\n    ```\n    \"\"\"\n    prefix: str\n    index: Dict[str, UUID]\n    size: int  # number of keys in this index (not including parent or subindex)  # noqa: E501\n    subindex: Index\n\n    def __init__(\n            self: Self,\n            index: Dict[str, UUID],\n            subindex: Index = None,\n            prefix: str = None,\n            size: int = None) -&gt; None:\n\"\"\"Index Constructor.\n\n        Index keys should be all one word lower case.\n        Index values should be UUIDs.\n        \"\"\"\n        self.prefix = prefix\n        self.index = index\n        self.subindex = subindex\n        self.size = size if size else len(index.keys())\n\n    def __str__(self: Self) -&gt; str:\n\"\"\"Convert an Index to a string with `str()`.\n\n        This will recursively parse the subindexes and\n        include them all in the response.\n\n        Returns:\n            str: The index object as a string\n        \"\"\"\n        return json.dumps(self.to_dict(), sort_keys=True, indent=4)\n\n    def __eq__(self: Self, other_index: Index) -&gt; bool:\n\"\"\"Compare two Index objects with `==`.\n\n        Args:\n            other_index (Index): The other index to compare\n\n        Returns:\n            bool: Returns true if self == other_index\n        \"\"\"\n        result = \\\n            self.prefix == other_index.prefix and \\\n            self.size == other_index.size and \\\n            self.subindex == other_index.subindex and \\\n            self.index == other_index.index\n        return result\n\n    def to_dict(self: Self) -&gt; dict:\n\"\"\"Convert the Index object to a dictionary.\n\n        This will recursively parse the subindexes and\n        include them all in the response.\n\n        Returns:\n            dict: The index object as a dict\n        \"\"\"\n        return {\n            \"prefix\": self.prefix,\n            \"index\": self.index,\n            \"subindex\": self.subindex.to_dict() if self.subindex else None\n        }\n\n    def matches(self: Self, other_index: Index) -&gt; bool:\n\"\"\"Check if this index has a compatible index with another index.\n\n        Args:\n            other_index (Index): The other index object to compare against\n\n        Returns:\n            bool: Returns false if any self keys are not in the other index\n                or if any values in self are not equal to the\n                corresponding value in the other index\n        \"\"\"\n        for key in self.index:\n            if key not in other_index.index:\n                return False\n\n            if str(self.index[key]) != str(other_index.index[key]):\n                return False\n\n        return True\n\n    def is_partial(self: Self) -&gt; bool:\n\"\"\"Check if the index has less keys than expected.\n\n        Returns:\n            bool: Returns true if some keys are missing\n        \"\"\"\n        return self.size != len(self.index.keys())\n\n    def get_metadata(self: Self) -&gt; Dict[str, UUID]:\n\"\"\"Parse the subindex/filename data.\n\n        This will recursively parse the subindexes and\n        include them all in the response.\n\n        Returns:\n            Dict[str, UUID]: A flat map of (key: value)\n        \"\"\"\n        filename = self.get_filename()  # recursively get subindex data\n        records = filename.split(\"/\")\n        if self.prefix:\n            records.pop(0)\n\n        result = {}\n        for index_level in records:\n            for index in index_level.split(\".\"):\n                result[index.split(\"_\")[0]] = index.split(\"_\")[1]\n\n        return result\n\n    def get_filename(self: Self) -&gt; str:\n\"\"\"Convert this object to a filename.\n\n        Returns:\n            str: The filename for this Index\n        \"\"\"\n        result = \"\"\n\n        # Add prefix\n        if self.prefix:\n            result += self.prefix + \"/\"\n\n        # If not all index keys are known, don't add it to the filename\n        if self.is_partial():\n            return result\n\n        # Add current index\n        cur_index = \".\".join([\n            f'{key}_{value}' for key, value in self.index.items()\n        ])\n        result += cur_index\n\n        # Recursively add subindexes\n        if self.subindex:\n            result += \"/\" + self.subindex.get_filename()\n\n        return result\n\n    @staticmethod\n    def from_filename(filename: str, has_prefix: bool = False) -&gt; Index:\n\"\"\"Convert a filename to an Index object.\n\n        Args:\n            filename (str): The filename to verify\n            has_prefix (bool, optional): Does the filename have a prefix?\n                Defaults to False.\n\n        Raises:\n            Exception: If the filename is unable to be parsed\n                an exception will be raised\n\n        Returns:\n            Index: The index object with data corresponding to\n                the input filename\n        \"\"\"\n        directories = [file for file in filename.split(\"/\") if file]\n\n        # Get prefix\n        prefix = directories.pop(0) if has_prefix else None\n\n        # Get index\n        try:\n            index = {\n                record.split(\"_\")[0]: record.split(\"_\")[1]\n                for record in directories.pop(0).split(\".\")\n            }\n        except IndexError as e:\n            raise Exception(f\"Could not parse filename `{filename}` with prefix `{prefix}`\") from e  # noqa: E501\n        except KeyError as e:\n            raise Exception(f\"Could not parse filename `{filename}` with prefix `{prefix}`\") from e  # noqa: E501\n\n        # Recursively get the subindexes\n        subindex = Index.from_filename(\"/\".join(directories)) if len(directories) &gt; 0 else None  # noqa: E501\n\n        return Index(index, subindex, prefix)\n</code></pre>"},{"location":"classes_index/#src.index.Index.__init__","title":"<code>__init__(index, subindex=None, prefix=None, size=None)</code>","text":"<p>Index Constructor.</p> <p>Index keys should be all one word lower case. Index values should be UUIDs.</p> Source code in <code>src/index.py</code> <pre><code>def __init__(\n        self: Self,\n        index: Dict[str, UUID],\n        subindex: Index = None,\n        prefix: str = None,\n        size: int = None) -&gt; None:\n\"\"\"Index Constructor.\n\n    Index keys should be all one word lower case.\n    Index values should be UUIDs.\n    \"\"\"\n    self.prefix = prefix\n    self.index = index\n    self.subindex = subindex\n    self.size = size if size else len(index.keys())\n</code></pre>"},{"location":"classes_index/#src.index.Index.__str__","title":"<code>__str__()</code>","text":"<p>Convert an Index to a string with <code>str()</code>.</p> <p>This will recursively parse the subindexes and include them all in the response.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The index object as a string</p> Source code in <code>src/index.py</code> <pre><code>def __str__(self: Self) -&gt; str:\n\"\"\"Convert an Index to a string with `str()`.\n\n    This will recursively parse the subindexes and\n    include them all in the response.\n\n    Returns:\n        str: The index object as a string\n    \"\"\"\n    return json.dumps(self.to_dict(), sort_keys=True, indent=4)\n</code></pre>"},{"location":"classes_index/#src.index.Index.__eq__","title":"<code>__eq__(other_index)</code>","text":"<p>Compare two Index objects with <code>==</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other_index</code> <code>Index</code> <p>The other index to compare</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns true if self == other_index</p> Source code in <code>src/index.py</code> <pre><code>def __eq__(self: Self, other_index: Index) -&gt; bool:\n\"\"\"Compare two Index objects with `==`.\n\n    Args:\n        other_index (Index): The other index to compare\n\n    Returns:\n        bool: Returns true if self == other_index\n    \"\"\"\n    result = \\\n        self.prefix == other_index.prefix and \\\n        self.size == other_index.size and \\\n        self.subindex == other_index.subindex and \\\n        self.index == other_index.index\n    return result\n</code></pre>"},{"location":"classes_index/#src.index.Index.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Index object to a dictionary.</p> <p>This will recursively parse the subindexes and include them all in the response.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The index object as a dict</p> Source code in <code>src/index.py</code> <pre><code>def to_dict(self: Self) -&gt; dict:\n\"\"\"Convert the Index object to a dictionary.\n\n    This will recursively parse the subindexes and\n    include them all in the response.\n\n    Returns:\n        dict: The index object as a dict\n    \"\"\"\n    return {\n        \"prefix\": self.prefix,\n        \"index\": self.index,\n        \"subindex\": self.subindex.to_dict() if self.subindex else None\n    }\n</code></pre>"},{"location":"classes_index/#src.index.Index.matches","title":"<code>matches(other_index)</code>","text":"<p>Check if this index has a compatible index with another index.</p> <p>Parameters:</p> Name Type Description Default <code>other_index</code> <code>Index</code> <p>The other index object to compare against</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns false if any self keys are not in the other index or if any values in self are not equal to the corresponding value in the other index</p> Source code in <code>src/index.py</code> <pre><code>def matches(self: Self, other_index: Index) -&gt; bool:\n\"\"\"Check if this index has a compatible index with another index.\n\n    Args:\n        other_index (Index): The other index object to compare against\n\n    Returns:\n        bool: Returns false if any self keys are not in the other index\n            or if any values in self are not equal to the\n            corresponding value in the other index\n    \"\"\"\n    for key in self.index:\n        if key not in other_index.index:\n            return False\n\n        if str(self.index[key]) != str(other_index.index[key]):\n            return False\n\n    return True\n</code></pre>"},{"location":"classes_index/#src.index.Index.is_partial","title":"<code>is_partial()</code>","text":"<p>Check if the index has less keys than expected.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Returns true if some keys are missing</p> Source code in <code>src/index.py</code> <pre><code>def is_partial(self: Self) -&gt; bool:\n\"\"\"Check if the index has less keys than expected.\n\n    Returns:\n        bool: Returns true if some keys are missing\n    \"\"\"\n    return self.size != len(self.index.keys())\n</code></pre>"},{"location":"classes_index/#src.index.Index.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Parse the subindex/filename data.</p> <p>This will recursively parse the subindexes and include them all in the response.</p> <p>Returns:</p> Type Description <code>Dict[str, UUID]</code> <p>Dict[str, UUID]: A flat map of (key: value)</p> Source code in <code>src/index.py</code> <pre><code>def get_metadata(self: Self) -&gt; Dict[str, UUID]:\n\"\"\"Parse the subindex/filename data.\n\n    This will recursively parse the subindexes and\n    include them all in the response.\n\n    Returns:\n        Dict[str, UUID]: A flat map of (key: value)\n    \"\"\"\n    filename = self.get_filename()  # recursively get subindex data\n    records = filename.split(\"/\")\n    if self.prefix:\n        records.pop(0)\n\n    result = {}\n    for index_level in records:\n        for index in index_level.split(\".\"):\n            result[index.split(\"_\")[0]] = index.split(\"_\")[1]\n\n    return result\n</code></pre>"},{"location":"classes_index/#src.index.Index.get_filename","title":"<code>get_filename()</code>","text":"<p>Convert this object to a filename.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The filename for this Index</p> Source code in <code>src/index.py</code> <pre><code>def get_filename(self: Self) -&gt; str:\n\"\"\"Convert this object to a filename.\n\n    Returns:\n        str: The filename for this Index\n    \"\"\"\n    result = \"\"\n\n    # Add prefix\n    if self.prefix:\n        result += self.prefix + \"/\"\n\n    # If not all index keys are known, don't add it to the filename\n    if self.is_partial():\n        return result\n\n    # Add current index\n    cur_index = \".\".join([\n        f'{key}_{value}' for key, value in self.index.items()\n    ])\n    result += cur_index\n\n    # Recursively add subindexes\n    if self.subindex:\n        result += \"/\" + self.subindex.get_filename()\n\n    return result\n</code></pre>"},{"location":"classes_index/#src.index.Index.from_filename","title":"<code>from_filename(filename, has_prefix=False)</code>  <code>staticmethod</code>","text":"<p>Convert a filename to an Index object.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to verify</p> required <code>has_prefix</code> <code>bool</code> <p>Does the filename have a prefix? Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the filename is unable to be parsed an exception will be raised</p> <p>Returns:</p> Name Type Description <code>Index</code> <code>Index</code> <p>The index object with data corresponding to the input filename</p> Source code in <code>src/index.py</code> <pre><code>@staticmethod\ndef from_filename(filename: str, has_prefix: bool = False) -&gt; Index:\n\"\"\"Convert a filename to an Index object.\n\n    Args:\n        filename (str): The filename to verify\n        has_prefix (bool, optional): Does the filename have a prefix?\n            Defaults to False.\n\n    Raises:\n        Exception: If the filename is unable to be parsed\n            an exception will be raised\n\n    Returns:\n        Index: The index object with data corresponding to\n            the input filename\n    \"\"\"\n    directories = [file for file in filename.split(\"/\") if file]\n\n    # Get prefix\n    prefix = directories.pop(0) if has_prefix else None\n\n    # Get index\n    try:\n        index = {\n            record.split(\"_\")[0]: record.split(\"_\")[1]\n            for record in directories.pop(0).split(\".\")\n        }\n    except IndexError as e:\n        raise Exception(f\"Could not parse filename `{filename}` with prefix `{prefix}`\") from e  # noqa: E501\n    except KeyError as e:\n        raise Exception(f\"Could not parse filename `{filename}` with prefix `{prefix}`\") from e  # noqa: E501\n\n    # Recursively get the subindexes\n    subindex = Index.from_filename(\"/\".join(directories)) if len(directories) &gt; 0 else None  # noqa: E501\n\n    return Index(index, subindex, prefix)\n</code></pre>"},{"location":"classes_ipfs/","title":"Ipfs","text":""},{"location":"classes_ipfs/#src.ipfs.Ipfs","title":"<code>src.ipfs.Ipfs</code>  <code>dataclass</code>","text":"<p>IPFS Python Client.</p> <p>This client uses the ipfs rpc via http. The ipfs server or gateway is specified in the constructor.</p>"},{"location":"classes_ipfs/#src.ipfs.Ipfs--usage","title":"Usage","text":"<p>For testing with a local ipfs node</p> <pre><code>    import ipfs\n    client = ipfs.Ipfs()  # defaults to http://127.0.0.1:5001/api/v0\n    client.mkdir(\"my_dir\")\n    client.add(\"my_dir/my_file\", b\"my_contents\")\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs--references","title":"References","text":"IPFS RPC documentation <p>https://docs.ipfs.tech/reference/kubo/rpc/#api-v0-files-write</p> For more information about ipfs <p>https://docs.ipfs.tech/concepts/what-is-ipfs/#defining-ipfs</p> Source code in <code>src/ipfs.py</code> <pre><code>@dataclass\nclass Ipfs():\n\"\"\"IPFS Python Client.\n\n    This client uses the ipfs rpc via http.\n    The ipfs server or gateway is specified in the constructor.\n\n    ### Usage\n    For testing with a local ipfs node\n    ```py\n        import ipfs\n        client = ipfs.Ipfs()  # defaults to http://127.0.0.1:5001/api/v0\n        client.mkdir(\"my_dir\")\n        client.add(\"my_dir/my_file\", b\"my_contents\")\n    ```\n\n    ### References\n\n    IPFS RPC documentation:\n        https://docs.ipfs.tech/reference/kubo/rpc/#api-v0-files-write\n\n    For more information about ipfs:\n        https://docs.ipfs.tech/concepts/what-is-ipfs/#defining-ipfs\n    \"\"\"\n    host: str\n    port: int\n    version: str\n\n    def __init__(\n            self: Self,\n            host: str = \"http://127.0.0.1\",\n            port: int = 5001,\n            version: str = \"v0\") -&gt; None:\n\"\"\"Create an IPFS client.\n\n        Args:\n            host (str, optional): IPFS server host or gateway host. Defaults to \"http://127.0.0.1\".  # noqa: E501\n            port (int, optional): IPFS port. Defaults to 5001.\n            version (str, optional): IPFS rpc version. Defaults to \"v0\".\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.version = version\n\n    def _make_request(\n            self: Self,\n            endpoint: str,\n            params: dict = None,\n            files: dict = None,\n            raise_for_status: bool = True) -&gt; bytes:\n\"\"\"Make an http request for an IPFS RPC call.\n\n        Args:\n            endpoint (str): The IPFS RPC endpoint\n            params (dict, optional): The RPC params. Defaults to None.\n            files (dict, optional): The RPC files. Defaults to None.\n            raise_for_status (bool, optional): If true, raise any\n                exceptions that are caught. Defaults to True.\n\n        Returns:\n            bytes: The http response data\n        \"\"\"\n        url = f\"{self.host}:{self.port}/api/{self.version}/{endpoint}\"\n        response = requests.post(url, params=params, files=files)\n        if raise_for_status:\n            response.raise_for_status()\n        return response.content\n\n    def _dag_put(self: Self, data: bytes) -&gt; str:\n\"\"\"Call the dag/put endpoint.\n\n        Args:\n            data (bytes): The raw object data\n\n        Raises:\n            RuntimeError: An exception is raised for any RPC errors\n\n        Returns:\n            str: The RPC response\n        \"\"\"\n        try:\n            response = self._make_request(\n                endpoint=\"dag/put\",\n                params={\n                    \"store-codec\": \"raw\",\n                    \"input-codec\": \"raw\"\n                },\n                files={\n                    \"object data\": add_prefix('raw', data)\n                },\n                raise_for_status=False\n            )\n            result = json.loads(response.decode())\n            return result[\"Cid\"][\"/\"]\n        except Exception as e:\n            print(e)\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def _dag_get(self: Self, filename: str) -&gt; str:\n\"\"\"Call the dag/get endpoint.\n\n        Args:\n            filename (str): The filename to get the dag for\n\n        Raises:\n            RuntimeError: An exception is raised for any RPC errors\n\n        Returns:\n            str: The RPC response\n        \"\"\"\n        try:\n            response = self._make_request(\n                endpoint=\"dag/get\",\n                params={\n                    \"arg\": filename,\n                    # \"output-codec\": \"raw\"\n                },\n                raise_for_status=False\n            )\n            return json.loads(response.decode())\n        except Exception as e:\n            print(e)\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def mkdir(self: Self, directory_name: str, with_home: bool = True) -&gt; None:\n\"\"\"Create a directory in ipfs.\n\n        Args:\n            directory_name (str): The name of the directory to create\n            with_home (bool, optional): If true, include Ipfs.IPFS_HOME\n                as a directory prefix. Defaults to True.\n\n        Raises:\n            RuntimeError: An exception is raised for any RPC errors\n        \"\"\"\n        # Split the filename into its directory and basename components\n        parts = os.path.split(directory_name)\n\n        # If the directory part is not empty, create it recursively\n        if parts[0]:\n            self.mkdir(parts[0])\n\n        path = f\"{IPFS_HOME}/{directory_name}\" if with_home else f\"/{directory_name}\"  # noqa: E501\n        try:\n            self._make_request(\n                endpoint=\"files/mkdir\",\n                params={\"arg\": path},\n                raise_for_status=False\n            )\n        except Exception as e:\n            print(e)\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def read(self: Self, filename: str) -&gt; bytes:\n\"\"\"Read a file from ipfs.\n\n        Args:\n            filename (str): The file to read\n\n        Returns:\n            (bytes): The file contents\n        \"\"\"\n        try:\n            return self._make_request(\n                endpoint=\"files/read\",\n                params={\"arg\": f\"{IPFS_HOME}/{filename}\"},\n            )\n        except Exception as e:\n            print(e)\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def write(self: Self, filename: str, data: bytes) -&gt; None:\n\"\"\"Overwrite file contents in ipfs.\n\n        Args:\n            filename (str): The filename to write to\n            data (bytes): The data to write\n\n        Raises:\n            NotImplementedError: This function is not implemented.\n                For now, just use `add` and `delete`\n        \"\"\"\n        raise NotImplementedError(\"For now, just use `add` and `delete`\")\n\n        try:\n            stat = self.stat(filename)\n            dag = self._dag_get(stat[\"Hash\"])\n            # print(dag)\n            # print(dag[\"/\"][\"bytes\"].encode)\n            example = Example()\n            example.ParseFromString(dag)\n            self._make_request(\n                endpoint=\"files/write\",\n                params={\n                    \"arg\": f\"{IPFS_HOME}/{filename}\",\n                    \"truncate\": True,\n                    \"raw-leaves\": True\n                },\n                files={\n                    'file': example.SerializeToString()\n                }\n            )\n        except requests.exceptions.HTTPError as e:\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def add(self: Self, filename: str, data: bytes) -&gt; None:\n\"\"\"Create a new file in ipfs.\n\n        This does not work for updating existing files.\n\n        Args:\n            filename (str): The filename for the uploaded data\n            data (bytes): The data that will be written to the new file\n        \"\"\"\n        # Split the filename into its directory and basename components\n        parts = os.path.split(filename)\n\n        # If the directory part is not empty, create it recursively\n        if parts[0]:\n            self.mkdir(parts[0])\n\n        try:\n            self._make_request(\n                endpoint=\"add\",\n                params={\n                    \"to-files\": f\"{IPFS_HOME}/{filename}\",\n                    \"raw-leaves\": True\n                },\n                files={\n                    'file': data\n                }\n            )\n        except Exception as e:\n            print(e)\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def does_file_exist(self: Self, filename: str) -&gt; bool:\n\"\"\"Check if a file exists in ipfs.\n\n        Args:\n            filename (str): The file to check\n\n        Returns:\n            bool: True if the file exists, false otherwise\n        \"\"\"\n        try:\n            response = self._make_request(\n                endpoint=\"files/stat\",\n                params={\"arg\": f\"{IPFS_HOME}/{filename}\"},\n                raise_for_status=False\n            )\n            return 'file does not exist' not in response.decode()\n        except Exception as e:\n            print(e)\n            if 'file does not exist' in e.response._content.decode():\n                return False\n\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def stat(self: Self, filename: str) -&gt; bytes:\n\"\"\"Call the files/stat endpoint.\n\n        Args:\n            filename (str): The path to search on ipfs\n\n        Returns:\n            bytes: The RPC response\n        \"\"\"\n        try:\n            return json.loads(self._make_request(\n                endpoint=\"files/stat\",\n                params={\"arg\": f\"{IPFS_HOME}/{filename}\"},\n                raise_for_status=False\n            ))\n        except Exception as e:\n            print(e)\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def list_files(self: Self, prefix: str = \"\") -&gt; List[str]:\n\"\"\"List the ipfs files in a directory.\n\n        Args:\n            prefix (str): The path to search on ipfs\n\n        Returns:\n            List[str]: The list of filenames found at that location\n        \"\"\"\n        try:\n            return json.loads(self._make_request(\n                endpoint=\"files/ls\",\n                params={\"arg\": f\"{IPFS_HOME}/{prefix}\"},\n                raise_for_status=False\n            ))\n        except Exception as e:\n            print(e)\n            raise RuntimeError(e.response._content.decode()) from e\n\n    def delete(self: Self, filename: str) -&gt; None:\n\"\"\"Delete a file from ipfs.\n\n        Args:\n            filename (str): The filename to delete\n        \"\"\"\n        try:\n            self._make_request(\n                endpoint=\"files/rm\",\n                params={\n                    \"arg\": f\"{IPFS_HOME}/{filename}\",\n                    \"recursive\": True\n                },\n                raise_for_status=False\n            )\n        except Exception as e:\n            print(e)\n            raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs.__init__","title":"<code>__init__(host='http://127.0.0.1', port=5001, version='v0')</code>","text":"<p>Create an IPFS client.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>IPFS server host or gateway host. Defaults to \"http://127.0.0.1\".  # noqa: E501</p> <code>'http://127.0.0.1'</code> <code>port</code> <code>int</code> <p>IPFS port. Defaults to 5001.</p> <code>5001</code> <code>version</code> <code>str</code> <p>IPFS rpc version. Defaults to \"v0\".</p> <code>'v0'</code> Source code in <code>src/ipfs.py</code> <pre><code>def __init__(\n        self: Self,\n        host: str = \"http://127.0.0.1\",\n        port: int = 5001,\n        version: str = \"v0\") -&gt; None:\n\"\"\"Create an IPFS client.\n\n    Args:\n        host (str, optional): IPFS server host or gateway host. Defaults to \"http://127.0.0.1\".  # noqa: E501\n        port (int, optional): IPFS port. Defaults to 5001.\n        version (str, optional): IPFS rpc version. Defaults to \"v0\".\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.version = version\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs._make_request","title":"<code>_make_request(endpoint, params=None, files=None, raise_for_status=True)</code>","text":"<p>Make an http request for an IPFS RPC call.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The IPFS RPC endpoint</p> required <code>params</code> <code>dict</code> <p>The RPC params. Defaults to None.</p> <code>None</code> <code>files</code> <code>dict</code> <p>The RPC files. Defaults to None.</p> <code>None</code> <code>raise_for_status</code> <code>bool</code> <p>If true, raise any exceptions that are caught. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The http response data</p> Source code in <code>src/ipfs.py</code> <pre><code>def _make_request(\n        self: Self,\n        endpoint: str,\n        params: dict = None,\n        files: dict = None,\n        raise_for_status: bool = True) -&gt; bytes:\n\"\"\"Make an http request for an IPFS RPC call.\n\n    Args:\n        endpoint (str): The IPFS RPC endpoint\n        params (dict, optional): The RPC params. Defaults to None.\n        files (dict, optional): The RPC files. Defaults to None.\n        raise_for_status (bool, optional): If true, raise any\n            exceptions that are caught. Defaults to True.\n\n    Returns:\n        bytes: The http response data\n    \"\"\"\n    url = f\"{self.host}:{self.port}/api/{self.version}/{endpoint}\"\n    response = requests.post(url, params=params, files=files)\n    if raise_for_status:\n        response.raise_for_status()\n    return response.content\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs._dag_put","title":"<code>_dag_put(data)</code>","text":"<p>Call the dag/put endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The raw object data</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>An exception is raised for any RPC errors</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The RPC response</p> Source code in <code>src/ipfs.py</code> <pre><code>def _dag_put(self: Self, data: bytes) -&gt; str:\n\"\"\"Call the dag/put endpoint.\n\n    Args:\n        data (bytes): The raw object data\n\n    Raises:\n        RuntimeError: An exception is raised for any RPC errors\n\n    Returns:\n        str: The RPC response\n    \"\"\"\n    try:\n        response = self._make_request(\n            endpoint=\"dag/put\",\n            params={\n                \"store-codec\": \"raw\",\n                \"input-codec\": \"raw\"\n            },\n            files={\n                \"object data\": add_prefix('raw', data)\n            },\n            raise_for_status=False\n        )\n        result = json.loads(response.decode())\n        return result[\"Cid\"][\"/\"]\n    except Exception as e:\n        print(e)\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs._dag_get","title":"<code>_dag_get(filename)</code>","text":"<p>Call the dag/get endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to get the dag for</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>An exception is raised for any RPC errors</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The RPC response</p> Source code in <code>src/ipfs.py</code> <pre><code>def _dag_get(self: Self, filename: str) -&gt; str:\n\"\"\"Call the dag/get endpoint.\n\n    Args:\n        filename (str): The filename to get the dag for\n\n    Raises:\n        RuntimeError: An exception is raised for any RPC errors\n\n    Returns:\n        str: The RPC response\n    \"\"\"\n    try:\n        response = self._make_request(\n            endpoint=\"dag/get\",\n            params={\n                \"arg\": filename,\n                # \"output-codec\": \"raw\"\n            },\n            raise_for_status=False\n        )\n        return json.loads(response.decode())\n    except Exception as e:\n        print(e)\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs.mkdir","title":"<code>mkdir(directory_name, with_home=True)</code>","text":"<p>Create a directory in ipfs.</p> <p>Parameters:</p> Name Type Description Default <code>directory_name</code> <code>str</code> <p>The name of the directory to create</p> required <code>with_home</code> <code>bool</code> <p>If true, include Ipfs.IPFS_HOME as a directory prefix. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>An exception is raised for any RPC errors</p> Source code in <code>src/ipfs.py</code> <pre><code>def mkdir(self: Self, directory_name: str, with_home: bool = True) -&gt; None:\n\"\"\"Create a directory in ipfs.\n\n    Args:\n        directory_name (str): The name of the directory to create\n        with_home (bool, optional): If true, include Ipfs.IPFS_HOME\n            as a directory prefix. Defaults to True.\n\n    Raises:\n        RuntimeError: An exception is raised for any RPC errors\n    \"\"\"\n    # Split the filename into its directory and basename components\n    parts = os.path.split(directory_name)\n\n    # If the directory part is not empty, create it recursively\n    if parts[0]:\n        self.mkdir(parts[0])\n\n    path = f\"{IPFS_HOME}/{directory_name}\" if with_home else f\"/{directory_name}\"  # noqa: E501\n    try:\n        self._make_request(\n            endpoint=\"files/mkdir\",\n            params={\"arg\": path},\n            raise_for_status=False\n        )\n    except Exception as e:\n        print(e)\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs.read","title":"<code>read(filename)</code>","text":"<p>Read a file from ipfs.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file to read</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The file contents</p> Source code in <code>src/ipfs.py</code> <pre><code>def read(self: Self, filename: str) -&gt; bytes:\n\"\"\"Read a file from ipfs.\n\n    Args:\n        filename (str): The file to read\n\n    Returns:\n        (bytes): The file contents\n    \"\"\"\n    try:\n        return self._make_request(\n            endpoint=\"files/read\",\n            params={\"arg\": f\"{IPFS_HOME}/{filename}\"},\n        )\n    except Exception as e:\n        print(e)\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs.add","title":"<code>add(filename, data)</code>","text":"<p>Create a new file in ipfs.</p> <p>This does not work for updating existing files.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename for the uploaded data</p> required <code>data</code> <code>bytes</code> <p>The data that will be written to the new file</p> required Source code in <code>src/ipfs.py</code> <pre><code>def add(self: Self, filename: str, data: bytes) -&gt; None:\n\"\"\"Create a new file in ipfs.\n\n    This does not work for updating existing files.\n\n    Args:\n        filename (str): The filename for the uploaded data\n        data (bytes): The data that will be written to the new file\n    \"\"\"\n    # Split the filename into its directory and basename components\n    parts = os.path.split(filename)\n\n    # If the directory part is not empty, create it recursively\n    if parts[0]:\n        self.mkdir(parts[0])\n\n    try:\n        self._make_request(\n            endpoint=\"add\",\n            params={\n                \"to-files\": f\"{IPFS_HOME}/{filename}\",\n                \"raw-leaves\": True\n            },\n            files={\n                'file': data\n            }\n        )\n    except Exception as e:\n        print(e)\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs.does_file_exist","title":"<code>does_file_exist(filename)</code>","text":"<p>Check if a file exists in ipfs.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The file to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the file exists, false otherwise</p> Source code in <code>src/ipfs.py</code> <pre><code>def does_file_exist(self: Self, filename: str) -&gt; bool:\n\"\"\"Check if a file exists in ipfs.\n\n    Args:\n        filename (str): The file to check\n\n    Returns:\n        bool: True if the file exists, false otherwise\n    \"\"\"\n    try:\n        response = self._make_request(\n            endpoint=\"files/stat\",\n            params={\"arg\": f\"{IPFS_HOME}/{filename}\"},\n            raise_for_status=False\n        )\n        return 'file does not exist' not in response.decode()\n    except Exception as e:\n        print(e)\n        if 'file does not exist' in e.response._content.decode():\n            return False\n\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs.stat","title":"<code>stat(filename)</code>","text":"<p>Call the files/stat endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to search on ipfs</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The RPC response</p> Source code in <code>src/ipfs.py</code> <pre><code>def stat(self: Self, filename: str) -&gt; bytes:\n\"\"\"Call the files/stat endpoint.\n\n    Args:\n        filename (str): The path to search on ipfs\n\n    Returns:\n        bytes: The RPC response\n    \"\"\"\n    try:\n        return json.loads(self._make_request(\n            endpoint=\"files/stat\",\n            params={\"arg\": f\"{IPFS_HOME}/{filename}\"},\n            raise_for_status=False\n        ))\n    except Exception as e:\n        print(e)\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs.list_files","title":"<code>list_files(prefix='')</code>","text":"<p>List the ipfs files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The path to search on ipfs</p> <code>''</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The list of filenames found at that location</p> Source code in <code>src/ipfs.py</code> <pre><code>def list_files(self: Self, prefix: str = \"\") -&gt; List[str]:\n\"\"\"List the ipfs files in a directory.\n\n    Args:\n        prefix (str): The path to search on ipfs\n\n    Returns:\n        List[str]: The list of filenames found at that location\n    \"\"\"\n    try:\n        return json.loads(self._make_request(\n            endpoint=\"files/ls\",\n            params={\"arg\": f\"{IPFS_HOME}/{prefix}\"},\n            raise_for_status=False\n        ))\n    except Exception as e:\n        print(e)\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_ipfs/#src.ipfs.Ipfs.delete","title":"<code>delete(filename)</code>","text":"<p>Delete a file from ipfs.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to delete</p> required Source code in <code>src/ipfs.py</code> <pre><code>def delete(self: Self, filename: str) -&gt; None:\n\"\"\"Delete a file from ipfs.\n\n    Args:\n        filename (str): The filename to delete\n    \"\"\"\n    try:\n        self._make_request(\n            endpoint=\"files/rm\",\n            params={\n                \"arg\": f\"{IPFS_HOME}/{filename}\",\n                \"recursive\": True\n            },\n            raise_for_status=False\n        )\n    except Exception as e:\n        print(e)\n        raise RuntimeError(e.response._content.decode()) from e\n</code></pre>"},{"location":"classes_store/","title":"Store","text":""},{"location":"classes_store/#src.store.Store","title":"<code>src.store.Store</code>  <code>dataclass</code>","text":"<p>A utility to read/write protobuf data to ipfs.</p> <p>Reading:</p> <pre><code>    from nanoswap.ipfskvs import Store, Index, Ipfs\n    from myprotobuf_pb2 import MyProtobuf\n\n    store = Store(\n        Index.from_filename(\"myfile.txt\"),\n        ipfs=Ipfs(host=\"127.0.0.1\", port=\"5001\"),\n        reader=MyProtobuf()\n    )\n    store.read()\n    print(store.reader)\n</code></pre> <p>Writing:</p> <pre><code>    from nanoswap.ipfskvs import Store, Index, Ipfs\n    from myprotobuf_pb2 import MyProtobuf\n\n    store = Store(\n        Index.from_filename(\"myfile.txt\"),\n        ipfs=Ipfs(host=\"127.0.0.1\", port=\"5001\"),\n        writer=MyProtobuf()\n    )\n    store.add()\n</code></pre> <p>Write with multiple indexes. Create a tiered file structure based on IDs.</p> <pre><code>    \u251c\u2500\u2500 fashion/\n        \u251c\u2500\u2500 designer_1.manufacturer_1\n        \u251c\u2500\u2500 designer_2.manufacturer_1\n            \u251c\u2500\u2500 deal_16.data\n        \u251c\u2500\u2500 designer_4.manufacturer_3\n            \u251c\u2500\u2500 deal_1.data\n            \u251c\u2500\u2500 deal_2.data\n</code></pre> <pre><code>    from nanoswap.ipfskvs import Store, Index, Ipfs\n    from deal_pb2 import Deal\n\n    index = Index(\n        prefix=\"fashion\",\n        index={\n            \"designer\": str(uuid.uuid4()),\n            \"manufacturer\": str(uuid.uuid4())\n        }, subindex=Index(\n            index={\n                \"deal\":  str(uuid.uuid4())\n            }\n        )\n    )\n\n    data = Deal(type=Type.BUZZ, content=\"fizz\")\n    store = Store(index=index, ipfs=Ipfs(), writer=data)\n    store.add()\n</code></pre> <p>Query the multiple indexes: Ex: get all deals with designer id \"123\"</p> <pre><code>    from nanoswap.ipfskvs import Store, Index, Ipfs\n    from deal_pb2 import Deal\n\n    query_index = Index(\n        prefix=\"fashion\",\n        index={\n            \"designer\": \"123\"\n        }\n    )\n    reader = Deal()\n    store = Store.query(query_index, ipfs, reader)\n    print(reader)\n</code></pre> Source code in <code>src/store.py</code> <pre><code>@dataclass\nclass Store():\n\"\"\"A utility to read/write protobuf data to ipfs.\n\n    Reading:\n    ```py\n        from nanoswap.ipfskvs import Store, Index, Ipfs\n        from myprotobuf_pb2 import MyProtobuf\n\n        store = Store(\n            Index.from_filename(\"myfile.txt\"),\n            ipfs=Ipfs(host=\"127.0.0.1\", port=\"5001\"),\n            reader=MyProtobuf()\n        )\n        store.read()\n        print(store.reader)\n    ```\n\n    Writing:\n    ```py\n        from nanoswap.ipfskvs import Store, Index, Ipfs\n        from myprotobuf_pb2 import MyProtobuf\n\n        store = Store(\n            Index.from_filename(\"myfile.txt\"),\n            ipfs=Ipfs(host=\"127.0.0.1\", port=\"5001\"),\n            writer=MyProtobuf()\n        )\n        store.add()\n    ```\n\n    Write with multiple indexes.\n    Create a tiered file structure based on IDs.\n    ```\n        \u251c\u2500\u2500 fashion/\n            \u251c\u2500\u2500 designer_1.manufacturer_1\n            \u251c\u2500\u2500 designer_2.manufacturer_1\n                \u251c\u2500\u2500 deal_16.data\n            \u251c\u2500\u2500 designer_4.manufacturer_3\n                \u251c\u2500\u2500 deal_1.data\n                \u251c\u2500\u2500 deal_2.data\n    ```\n    ```py\n        from nanoswap.ipfskvs import Store, Index, Ipfs\n        from deal_pb2 import Deal\n\n        index = Index(\n            prefix=\"fashion\",\n            index={\n                \"designer\": str(uuid.uuid4()),\n                \"manufacturer\": str(uuid.uuid4())\n            }, subindex=Index(\n                index={\n                    \"deal\":  str(uuid.uuid4())\n                }\n            )\n        )\n\n        data = Deal(type=Type.BUZZ, content=\"fizz\")\n        store = Store(index=index, ipfs=Ipfs(), writer=data)\n        store.add()\n    ```\n\n    Query the multiple indexes:\n    Ex: get all deals with designer id \"123\"\n    ```py\n        from nanoswap.ipfskvs import Store, Index, Ipfs\n        from deal_pb2 import Deal\n\n        query_index = Index(\n            prefix=\"fashion\",\n            index={\n                \"designer\": \"123\"\n            }\n        )\n        reader = Deal()\n        store = Store.query(query_index, ipfs, reader)\n        print(reader)\n    ```\n    \"\"\"\n    index: Index\n    writer: Message\n    reader: Message\n\n    def __init__(\n            self: Self,\n            index: Index,\n            ipfs: Ipfs,\n            writer: Message = None,\n            reader: Message = None) -&gt; None:\n\"\"\"Construct a Store object.\n\n        Args:\n            index (Index): An object representing the filepath\n            ipfs (Ipfs): The IPFS client\n            writer (Message, optional): The protobuf object with the\n                data to write to ipfs on `.write()`. Defaults to None.\n            reader (Message, optional): The protobuf object to populate\n                when reading the data from ipfs with `.read()`.\n                Defaults to None.\n        \"\"\"\n        self.index = index\n        self.ipfs = ipfs\n        self.writer = writer\n        self.reader = reader\n\n    def read(self: Self) -&gt; None:\n\"\"\"Read the data from ipfs into `self.reader`.\n\n        Raises:\n            FileNotFoundError: An exception is raised if the file is\n                not found on IPFS.\n        \"\"\"\n        filename = self.index.get_filename()\n        result = self.ipfs.read(filename)\n        if not result:\n            raise FileNotFoundError(\n                errno.ENOENT,\n                os.strerror(errno.ENOENT),\n                filename\n            )\n\n        self.reader.ParseFromString(result)\n\n    def write(self: Self) -&gt; None:\n\"\"\"Write the protobuf data from `self.writer` to IPFS.\"\"\"\n        raise NotImplementedError(\"For now, just use `add` and `delete`\")\n        self.ipfs.write(\n            self.index.get_filename(),\n            self.writer.SerializeToString()\n        )\n\n    def add(self: Self) -&gt; None:\n\"\"\"Add the protobuf data from `self.writer` to IPFS.\"\"\"\n        self.ipfs.add(\n            self.index.get_filename(),\n            self.writer.SerializeToString()\n        )\n\n    def delete(self: Self) -&gt; None:\n\"\"\"Only needed for local testing.\"\"\"\n        self.ipfs.delete(self.index.get_filename())\n\n    @staticmethod\n    def to_dataframe(\n            data: List[Store],\n            protobuf_parsers: Dict[str, FunctionType]) -&gt; pd.DataFrame:\n\"\"\"Convert a list of Store objects to a pandas dataframe.\n\n        The data for each Store must be read into memory beforehand;\n            using `store.read()`\n\n        Args:\n            data (List[Store]): The list of Store objects with Indexes\n            protobuf_parsers: (Dict[str, function]): key, value pair of\n                key (str) --&gt; pandas column name\n                value (function) --&gt; how to extract the value from the store\n\n                The function should accept a Store object and return Any\n\n        Returns:\n            pd.DataFrame: The index and subindex data\n                reformatted into a dataframe\n        \"\"\"\n        pandas_input = {}\n        for store in data:\n\n            # add metadata\n            metadata = store.index.get_metadata()\n            for key in metadata:\n                if key not in pandas_input:\n                    pandas_input[key] = []\n\n                pandas_input[key].append(metadata[key])\n\n            # add top level data from the reader\n            for key in protobuf_parsers:\n                if key not in pandas_input:\n                    pandas_input[key] = []\n\n                pandas_input[key].append(protobuf_parsers[key](store))\n\n        # load the data into a pandas dataframe\n        return pd.DataFrame.from_dict(pandas_input)\n\n    @staticmethod\n    def query_indexes(query_index: Index, ipfs: Ipfs) -&gt; List[Index]:\n\"\"\"Query ipfs based on the `query_index` param.\n\n        Args:\n            query_index (Index): The Index object to use for the query.\n            ipfs (Ipfs): The IPFS client.\n\n        Returns:\n            List[Index]: The matching filenames found in ipfs, loaded\n                into a list of Index objects\n        \"\"\"\n        result = []\n\n        # list the files in the directory\n        path = query_index.get_filename()\n        response = ipfs.list_files(path)\n        filenames = [file['Name'] for file in response['Entries']]\n        for filename in filenames:\n            # Listing the same file twice indicates the base case\n            #   ex:\n            #       path = `ls dir1/dir2` --&gt; filenames = [\"filename\"]\n            #       path = `ls dir1/dir2/filename` --&gt; filenames = [\"filename\"]\n            if filename in path:\n                return [query_index]\n\n            # filter filenames based on the index\n            full_filename = f\"{path}/{filename}\".replace(\"//\", \"/\")\n            from_index = Index.from_filename(\n                filename=full_filename,\n                has_prefix=query_index.prefix\n            )\n            if query_index.matches(from_index):\n                result += Store.query_indexes(from_index, ipfs)\n\n        return result\n\n    @staticmethod\n    def query(\n            query_index: Index,\n            ipfs: Ipfs,\n            reader: Message) -&gt; Iterator[Store]:\n\"\"\"Query ipfs based on the `query_index` param.\n\n        Find the filenames matching the query_index.\n        Read the file contents from ipfs for each matching filename.\n        Parse the file contents into the reader protobuf object.\n\n        Args:\n            query_index (Index): The Index object to use for the query.\n            ipfs (Ipfs): The IPFS client.\n            reader (Message): _description_\n\n        Yields:\n            Iterator[Store]: The list of matching Store objects with\n                file content loaded into the `reader` attribute\n        \"\"\"\n        for response_index in Store.query_indexes(query_index, ipfs):\n            store = Store(index=response_index, reader=reader, ipfs=ipfs)\n            store.read()\n            yield store\n</code></pre>"},{"location":"classes_store/#src.store.Store.__init__","title":"<code>__init__(index, ipfs, writer=None, reader=None)</code>","text":"<p>Construct a Store object.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>An object representing the filepath</p> required <code>ipfs</code> <code>Ipfs</code> <p>The IPFS client</p> required <code>writer</code> <code>Message</code> <p>The protobuf object with the data to write to ipfs on <code>.write()</code>. Defaults to None.</p> <code>None</code> <code>reader</code> <code>Message</code> <p>The protobuf object to populate when reading the data from ipfs with <code>.read()</code>. Defaults to None.</p> <code>None</code> Source code in <code>src/store.py</code> <pre><code>def __init__(\n        self: Self,\n        index: Index,\n        ipfs: Ipfs,\n        writer: Message = None,\n        reader: Message = None) -&gt; None:\n\"\"\"Construct a Store object.\n\n    Args:\n        index (Index): An object representing the filepath\n        ipfs (Ipfs): The IPFS client\n        writer (Message, optional): The protobuf object with the\n            data to write to ipfs on `.write()`. Defaults to None.\n        reader (Message, optional): The protobuf object to populate\n            when reading the data from ipfs with `.read()`.\n            Defaults to None.\n    \"\"\"\n    self.index = index\n    self.ipfs = ipfs\n    self.writer = writer\n    self.reader = reader\n</code></pre>"},{"location":"classes_store/#src.store.Store.read","title":"<code>read()</code>","text":"<p>Read the data from ipfs into <code>self.reader</code>.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>An exception is raised if the file is not found on IPFS.</p> Source code in <code>src/store.py</code> <pre><code>def read(self: Self) -&gt; None:\n\"\"\"Read the data from ipfs into `self.reader`.\n\n    Raises:\n        FileNotFoundError: An exception is raised if the file is\n            not found on IPFS.\n    \"\"\"\n    filename = self.index.get_filename()\n    result = self.ipfs.read(filename)\n    if not result:\n        raise FileNotFoundError(\n            errno.ENOENT,\n            os.strerror(errno.ENOENT),\n            filename\n        )\n\n    self.reader.ParseFromString(result)\n</code></pre>"},{"location":"classes_store/#src.store.Store.add","title":"<code>add()</code>","text":"<p>Add the protobuf data from <code>self.writer</code> to IPFS.</p> Source code in <code>src/store.py</code> <pre><code>def add(self: Self) -&gt; None:\n\"\"\"Add the protobuf data from `self.writer` to IPFS.\"\"\"\n    self.ipfs.add(\n        self.index.get_filename(),\n        self.writer.SerializeToString()\n    )\n</code></pre>"},{"location":"classes_store/#src.store.Store.delete","title":"<code>delete()</code>","text":"<p>Only needed for local testing.</p> Source code in <code>src/store.py</code> <pre><code>def delete(self: Self) -&gt; None:\n\"\"\"Only needed for local testing.\"\"\"\n    self.ipfs.delete(self.index.get_filename())\n</code></pre>"},{"location":"classes_store/#src.store.Store.to_dataframe","title":"<code>to_dataframe(data, protobuf_parsers)</code>  <code>staticmethod</code>","text":"<p>Convert a list of Store objects to a pandas dataframe.</p> <p>The data for each Store must be read into memory beforehand;     using <code>store.read()</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[Store]</code> <p>The list of Store objects with Indexes</p> required <code>protobuf_parsers</code> <code>Dict[str, FunctionType]</code> <p>(Dict[str, function]): key, value pair of key (str) --&gt; pandas column name value (function) --&gt; how to extract the value from the store</p> <p>The function should accept a Store object and return Any</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: The index and subindex data reformatted into a dataframe</p> Source code in <code>src/store.py</code> <pre><code>@staticmethod\ndef to_dataframe(\n        data: List[Store],\n        protobuf_parsers: Dict[str, FunctionType]) -&gt; pd.DataFrame:\n\"\"\"Convert a list of Store objects to a pandas dataframe.\n\n    The data for each Store must be read into memory beforehand;\n        using `store.read()`\n\n    Args:\n        data (List[Store]): The list of Store objects with Indexes\n        protobuf_parsers: (Dict[str, function]): key, value pair of\n            key (str) --&gt; pandas column name\n            value (function) --&gt; how to extract the value from the store\n\n            The function should accept a Store object and return Any\n\n    Returns:\n        pd.DataFrame: The index and subindex data\n            reformatted into a dataframe\n    \"\"\"\n    pandas_input = {}\n    for store in data:\n\n        # add metadata\n        metadata = store.index.get_metadata()\n        for key in metadata:\n            if key not in pandas_input:\n                pandas_input[key] = []\n\n            pandas_input[key].append(metadata[key])\n\n        # add top level data from the reader\n        for key in protobuf_parsers:\n            if key not in pandas_input:\n                pandas_input[key] = []\n\n            pandas_input[key].append(protobuf_parsers[key](store))\n\n    # load the data into a pandas dataframe\n    return pd.DataFrame.from_dict(pandas_input)\n</code></pre>"},{"location":"classes_store/#src.store.Store.query_indexes","title":"<code>query_indexes(query_index, ipfs)</code>  <code>staticmethod</code>","text":"<p>Query ipfs based on the <code>query_index</code> param.</p> <p>Parameters:</p> Name Type Description Default <code>query_index</code> <code>Index</code> <p>The Index object to use for the query.</p> required <code>ipfs</code> <code>Ipfs</code> <p>The IPFS client.</p> required <p>Returns:</p> Type Description <code>List[Index]</code> <p>List[Index]: The matching filenames found in ipfs, loaded into a list of Index objects</p> Source code in <code>src/store.py</code> <pre><code>@staticmethod\ndef query_indexes(query_index: Index, ipfs: Ipfs) -&gt; List[Index]:\n\"\"\"Query ipfs based on the `query_index` param.\n\n    Args:\n        query_index (Index): The Index object to use for the query.\n        ipfs (Ipfs): The IPFS client.\n\n    Returns:\n        List[Index]: The matching filenames found in ipfs, loaded\n            into a list of Index objects\n    \"\"\"\n    result = []\n\n    # list the files in the directory\n    path = query_index.get_filename()\n    response = ipfs.list_files(path)\n    filenames = [file['Name'] for file in response['Entries']]\n    for filename in filenames:\n        # Listing the same file twice indicates the base case\n        #   ex:\n        #       path = `ls dir1/dir2` --&gt; filenames = [\"filename\"]\n        #       path = `ls dir1/dir2/filename` --&gt; filenames = [\"filename\"]\n        if filename in path:\n            return [query_index]\n\n        # filter filenames based on the index\n        full_filename = f\"{path}/{filename}\".replace(\"//\", \"/\")\n        from_index = Index.from_filename(\n            filename=full_filename,\n            has_prefix=query_index.prefix\n        )\n        if query_index.matches(from_index):\n            result += Store.query_indexes(from_index, ipfs)\n\n    return result\n</code></pre>"},{"location":"classes_store/#src.store.Store.query","title":"<code>query(query_index, ipfs, reader)</code>  <code>staticmethod</code>","text":"<p>Query ipfs based on the <code>query_index</code> param.</p> <p>Find the filenames matching the query_index. Read the file contents from ipfs for each matching filename. Parse the file contents into the reader protobuf object.</p> <p>Parameters:</p> Name Type Description Default <code>query_index</code> <code>Index</code> <p>The Index object to use for the query.</p> required <code>ipfs</code> <code>Ipfs</code> <p>The IPFS client.</p> required <code>reader</code> <code>Message</code> <p>description</p> required <p>Yields:</p> Type Description <code>Iterator[Store]</code> <p>Iterator[Store]: The list of matching Store objects with file content loaded into the <code>reader</code> attribute</p> Source code in <code>src/store.py</code> <pre><code>@staticmethod\ndef query(\n        query_index: Index,\n        ipfs: Ipfs,\n        reader: Message) -&gt; Iterator[Store]:\n\"\"\"Query ipfs based on the `query_index` param.\n\n    Find the filenames matching the query_index.\n    Read the file contents from ipfs for each matching filename.\n    Parse the file contents into the reader protobuf object.\n\n    Args:\n        query_index (Index): The Index object to use for the query.\n        ipfs (Ipfs): The IPFS client.\n        reader (Message): _description_\n\n    Yields:\n        Iterator[Store]: The list of matching Store objects with\n            file content loaded into the `reader` attribute\n    \"\"\"\n    for response_index in Store.query_indexes(query_index, ipfs):\n        store = Store(index=response_index, reader=reader, ipfs=ipfs)\n        store.read()\n        yield store\n</code></pre>"}]}